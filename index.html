<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="theme-color" content="#02030e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="icon-180x180.png">
  <title>Block Laser Breaker</title>
  <style>
    :root{ --bg:#02030e; --fg:#eaf2ff; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Sans","Noto Sans JP",sans-serif; }
    body{ overflow:hidden; -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
    /* iPhoneの長押し拡大/ダブルタップ拡大を抑制 */
    #wrap{ position:fixed; inset:0; display:grid; place-items:center; touch-action:none; }
    canvas{ width:100vw; height:100vh; image-rendering: pixelated; image-rendering: crisp-edges; touch-action:none; }
    #hud{
      position:fixed; top:10px; left:10px; z-index:4;
      display:flex; gap:8px; align-items:center;
      font-weight:800; letter-spacing:0.04em;
      font-size:12px;
      background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12);
      padding:6px 8px; border-radius:10px;
      backdrop-filter: blur(4px);
    }
    #hud .dot{ width:8px; height:8px; border-radius:2px; background:#fff; opacity:.85; }
    #overlay{
      position:fixed; inset:0; z-index:10;
      display:grid; place-items:center;
      background:rgba(0,0,0,.72);
    }
    #overlay.hidden{ display:none; }
    #card{
      width:min(520px, calc(100vw - 28px));
      border-radius:18px;
      border:2px solid rgba(255,255,255,.12);
      background:rgba(2,3,14,.9);
      box-shadow:0 18px 60px rgba(0,0,0,.6);
      padding:16px 16px 14px;
    }
    #title{ font-weight:1000; font-size:18px; margin:0 0 8px; letter-spacing:.06em; }
    #sub{ margin:0 0 12px; opacity:.9; font-size:13px; line-height:1.5; }
    #menuBtns{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    button{
      appearance:none; border:0; cursor:pointer;
      border-radius:14px; padding:12px 12px;
      font-weight:1000; letter-spacing:.08em;
      color:#041019;
      background: linear-gradient(90deg, #00ffff, #ff00ff, #ffff00);
      box-shadow:0 8px 26px rgba(0,0,0,.4);
    }
    button:active{ transform: translateY(1px); }
    .k{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.18); padding:0 6px; border-radius:8px; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="c"></canvas></div>
  <div id="hud" aria-hidden="true">
    <span class="dot"></span><span id="lv">LV 1</span>
    <span style="opacity:.45;">|</span>
    <span id="hp">HP 3</span>
    <span style="opacity:.45;">|</span>
    <span id="prog">0%</span>
  </div>

  <div id="overlay">
    <div id="card">
      <h1 id="title">BLOCK LASER BREAKER</h1>
      <p id="sub">
        <span class="k">Space</span>/<span class="k">Enter</span> でSTART。<br>
        PC: カーソル左右 / マウス。 スマホ: 指で左右スライド。<br>
        カプセル取得でルーレット（2つ）。回ってる間は停止。<br>
      </p>
      <div id="menuBtns">
        <button id="startBtn" type="button">START</button>
        <button id="demoBtn" type="button">DEMO</button>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp  = (a,b,t)=>a+(b-a)*t;
  const rnd   = (a,b)=>a+Math.random()*(b-a);
  const irnd  = (a,b)=>Math.floor(rnd(a,b+1));

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });
  const DPR = Math.min(2, window.devicePixelRatio || 1);

  const overlay = document.getElementById("overlay");
  const card = document.getElementById("card");
  const startBtn = document.getElementById("startBtn");
  const demoBtn = document.getElementById("demoBtn");
  const elLv = document.getElementById("lv");
  const elHp = document.getElementById("hp");
  const elProg = document.getElementById("prog");

  card.addEventListener("pointerdown", (e)=>{ e.stopPropagation(); }, {passive:true});

  window.addEventListener("contextmenu", (e)=>e.preventDefault());
  window.addEventListener("gesturestart", (e)=>e.preventDefault());
  window.addEventListener("gesturechange", (e)=>e.preventDefault());
  window.addEventListener("gestureend", (e)=>e.preventDefault());

  function showOverlay(){ overlay.classList.remove("hidden"); }
  function hideOverlay(){ overlay.classList.add("hidden"); }

  // Audio
  let ac=null, master=null;
  function initAudio(){
    if (ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();
    master = ac.createGain();
    master.gain.value = 0.22;
    master.connect(ac.destination);
  }
  function beep(freq=440, dur=0.08, type="square", vol=0.6, glide=null){
    if(!ac) return;
    const t0 = ac.currentTime;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    if (glide) o.frequency.exponentialRampToValueAtTime(glide, t0+dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, vol), t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
    o.connect(g); g.connect(master);
    o.start(t0); o.stop(t0+dur+0.02);
  }
  function sfxRoulette(value){
    if(!ac) return;
    if (value === "★"){
      beep(660,0.07,"square",0.9, 990);
      beep(990,0.10,"triangle",0.8, 1320);
      return;
    }
    if (value === "×"){
      beep(220,0.08,"sawtooth",0.9, 110);
      beep(110,0.10,"sawtooth",0.8, 55);
      return;
    }
    const n = value|0;
    const base = 260 + n*70;
    beep(base, 0.06, "square", 0.7, base*2);
    if (n>=3) beep(base*1.5, 0.07, "triangle", 0.6, base*2.2);
    if (n>=4) beep(base*2.0, 0.08, "sawtooth", 0.55, base*3.0);
    if (n>=5) { beep(1240,0.10,"triangle",0.5, 1860); beep(930,0.12,"square",0.45, 1400); }
  }
  function sfxHit(){ beep(420,0.04,"square",0.45, 520); }
  function sfxClank(){ beep(160,0.06,"square",0.55, 120); }
  function sfxLose(){ beep(180,0.12,"sawtooth",0.7, 60); }
  function sfxLaser(){ beep(880,0.05,"square",0.55, 1320); }

  const game = {
    running:false, demo:false, paused:false, waitingServe:true,
    time:0, level:1, hp:3, stageProgress:0, stageLength:2400, hue:0,
    ballStage:1, laserStage:1, paddleStage:1,
    laserActive:false, laserTimer:0,
    px:0.5, pxTarget:0.5,
    balls:[], blocks:[], capsules:[], missiles:[], particles:[], roulette:null,
  };

  let W=720, H=1280;
  function resize(){
    const w = Math.floor(window.innerWidth * DPR);
    const h = Math.floor(window.innerHeight * DPR);
    canvas.width = w; canvas.height = h;
    const ar = w / h;
    if (ar > 0.75){
      H = 1200;
      W = Math.round(H * ar);
    } else {
      W = 720;
      H = Math.round(W / ar);
    }
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  function paddle(){
    const coreW = 36, coreH = 22;
    const beamLen = [220, 280, 340, 400, 460][game.paddleStage-1];
    const y = H - 120;
    const x = lerp(0, W, game.px);
    return { x, y, coreW, coreH, beamLen };
  }

  function resetToInitial(){
    game.ballStage = 1; game.laserStage = 1; game.paddleStage = 1;
    game.laserActive = false; game.laserTimer = 0;
  }

  function spawnBallSplit(count){
    const cap = 80;
    const addPer = count|0;
    const cur = game.balls.slice();
    for (const b of cur){
      for (let i=0;i<addPer;i++){
        if (game.balls.length >= cap) return;
        const ang = Math.atan2(b.vy, b.vx) + rnd(-0.55, 0.55);
        const sp = Math.hypot(b.vx, b.vy) * rnd(0.92, 1.08);
        game.balls.push({ x:b.x, y:b.y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:b.r });
      }
    }
  }

  function serve(){
    if (game.balls.length === 0){
      const p = paddle();
      game.balls.push({ x:p.x, y:p.y-40, vx:rnd(-220,220), vy:-620, r:8 });
    } else {
      for (const b of game.balls){
        if (b.vy > -120) b.vy = -Math.abs(b.vy) - 300;
      }
    }
    game.waitingServe = false;
  }

  function spawnStageStartCapsule(){
    const x = rnd(0.2, 0.8) * W;
    game.capsules.push({ x, y:-30, vy:220, r:14 });
  }

  function spawnCapsuleRare(){
    if (Math.random() < 0.010){
      const x = rnd(0.1, 0.9) * W;
      game.capsules.push({ x, y:-30, vy:240, r:14 });
    }
  }

  function spawnBlockRow(){
    const cols = 10, margin = 40, gap = 8;
    const bw = Math.floor((W - margin*2 - gap*(cols-1))/cols);
    const bh = 26;
    const y = -bh - 6;
    for (let c=0;c<cols;c++){
      if (Math.random() < 0.20) continue;
      const x = margin + c*(bw+gap);
      const unbreak = (game.level>=2 && Math.random() < Math.min(0.10 + game.level*0.02, 0.22));
      const hp = unbreak ? 999 : (1 + (game.level>=3 && Math.random()<0.25 ? 1 : 0));
      game.blocks.push({ x, y, w:bw, h:bh, hp, unbreak });
    }
  }

  function spawnMissileMaybe(){
    if (game.level < 2) return;
    const chance = Math.min(0.003 + game.level*0.001, 0.010);
    if (Math.random() < chance){
      const x = rnd(0.05, 0.95)*W;
      game.missiles.push({ x, y:-20, vy:320 + game.level*30, r:8 });
      if (ac) beep(520,0.05,"square",0.35, 780);
    }
  }

  function startRoulette(){
    game.paused = true;
    game.roulette = {
      t:0, dur:0.95,
      a:{ list:["BALL","LASER","PADDLE","★","×"], idx:0 },
      b:{ list:[1,2,3,4,5,"★","×"], idx:0 },
      resultA:null, resultB:null,
    };
    if (ac){
      beep(320,0.05,"square",0.35, 520);
      beep(520,0.06,"triangle",0.25, 760);
    }
  }

  function burst(x,y,n){
    for (let i=0;i<n;i++){
      game.particles.push({ x,y, vx:rnd(-260,260), vy:rnd(-360,120), t:0, life:rnd(0.25,0.6), s:irnd(2,4) });
    }
  }

  function finishRoulette(){
    const r = game.roulette;
    const A = r.resultA, B = r.resultB;

    if (A==="★" && B==="★"){
      for (const bl of game.blocks) burst(bl.x+bl.w/2, bl.y+bl.h/2, 18);
      game.blocks.length = 0;
      if (ac) sfxRoulette("★");
    } else if (A==="×" && B==="×"){
      resetToInitial();
      if (ac) sfxRoulette("×");
    } else {
      if (A==="BALL" && typeof B==="number"){
        spawnBallSplit(B);
        game.ballStage = clamp(B,1,5);
        if (ac) sfxRoulette(B);
      } else if (A==="LASER" && typeof B==="number"){
        game.laserStage = clamp(B,1,5);
        game.laserActive = true;
        game.laserTimer = 2.0;
        if (ac) sfxRoulette(B);
      } else if (A==="PADDLE" && typeof B==="number"){
        game.paddleStage = clamp(B,1,5);
        if (ac) sfxRoulette(B);
      } else {
        const key = (typeof B==="number")?B:(B==="★"?"★":"×");
        if (ac) sfxRoulette(key);
      }
    }

    game.roulette = null;
    game.paused = false;
  }

  function updateHud(){
    elLv.textContent = "LV " + game.level;
    elHp.textContent = "HP " + game.hp;
    const p = clamp(game.stageProgress / Math.max(1, game.stageLength), 0, 1);
    elProg.textContent = Math.round(p*100) + "%";
  }

  function nextStage(){
    resetToInitial();
    game.level += 1;
    game.stageProgress = 0;
    game.stageLength = 2400 + (game.level-1)*520;
    game.hue = (game.hue + 60) % 360;
    game.blocks.length = 0;
    game.capsules.length = 0;
    game.missiles.length = 0;
    spawnStageStartCapsule();
    if (ac){
      beep(520,0.06,"square",0.35, 780);
      beep(780,0.08,"triangle",0.32, 1040);
      beep(1040,0.10,"triangle",0.28, 1560);
    }
    updateHud();
  }

  function loseLife(){
    game.hp -= 1;
    if (ac) sfxLose();
    if (navigator.vibrate) navigator.vibrate(18);

    if (game.hp <= 0){
      game.running = false;
      game.demo = false;
      showOverlay();
      game.balls.length = 0; // restart will start with 1
      spawnStageStartCapsule();
      updateHud();
      return;
    }

    game.waitingServe = true;
    while (game.balls.length > 1) game.balls.pop();
    const p = paddle();
    if (game.balls.length === 0) game.balls.push({ x:p.x, y:p.y-40, vx:rnd(-200,200), vy:-640, r:8 });
    else {
      const b = game.balls[0];
      b.x = p.x; b.y = p.y-40; b.vx = rnd(-200,200); b.vy = -640;
    }
    updateHud();
  }

  function demoControl(){
    if (game.balls.length>0){
      let target = game.balls[0];
      for (const b of game.balls) if (b.y > target.y) target = b;
      game.pxTarget = clamp(target.x / W, 0.02, 0.98);
    } else {
      game.pxTarget = 0.5;
    }
  }

  function aabbHitCircle(rx,ry,rw,rh,cx,cy,cr){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  // Input
  let pointerDown = false;
  function setPXFromClientX(clientX){
    const rect = canvas.getBoundingClientRect();
    const nx = (clientX - rect.left) / rect.width;
    game.pxTarget = clamp(nx, 0.02, 0.98);
  }
  canvas.addEventListener("pointerdown", (e)=>{
    initAudio();
    pointerDown = true;
    setPXFromClientX(e.clientX);
    canvas.setPointerCapture?.(e.pointerId);
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener("pointermove", (e)=>{
    if(!pointerDown) return;
    setPXFromClientX(e.clientX);
    e.preventDefault();
  }, {passive:false});
  canvas.addEventListener("pointerup", (e)=>{
    pointerDown = false;
    e.preventDefault();
  }, {passive:false});

  window.addEventListener("keydown", (e)=>{
    if (e.key === " " || e.key === "Enter"){
      initAudio();
      if (!game.running){
        startGame(false);
      } else if (game.waitingServe && !game.paused){
        serve();
      }
      e.preventDefault();
      return;
    }
    if (!game.running) return;
    if (e.key === "ArrowLeft") game.pxTarget = clamp(game.pxTarget - 0.04, 0.02, 0.98);
    if (e.key === "ArrowRight") game.pxTarget = clamp(game.pxTarget + 0.04, 0.02, 0.98);
  });

  startBtn.addEventListener("click", ()=>{ initAudio(); startGame(false); });
  demoBtn.addEventListener("click",  ()=>{ initAudio(); startGame(true); });

  function startGame(demo){
    hideOverlay();
    game.running = true;
    game.demo = !!demo;
    game.paused = false;
    game.waitingServe = true;
    game.time = 0;
    game.hp = 3;
    game.level = 1;
    game.stageProgress = 0;
    game.stageLength = 2400;
    game.hue = 0;
    resetToInitial();
    game.blocks.length = 0;
    game.capsules.length = 0;
    game.missiles.length = 0;
    game.particles.length = 0;
    game.balls.length = 0;

    const p = paddle();
    game.balls.push({ x:p.x, y:p.y-40, vx:rnd(-200,200), vy:-640, r:8 });

    spawnStageStartCapsule();
    updateHud();
  }

  // Main tick
  function tick(dt){
    game.time += dt;

    if (game.demo) demoControl();
    game.px = lerp(game.px, game.pxTarget, clamp(dt*10, 0, 1));

    if (!game.running) return;

    if (game.paused){
      const r = game.roulette;
      if (r){
        r.t += dt;
        const t = clamp(r.t / r.dur, 0, 1);
        const speed = lerp(24, 8, t);
        r.a.idx = (r.a.idx + speed*dt*10) % r.a.list.length;
        r.b.idx = (r.b.idx + speed*dt*12) % r.b.list.length;
        if (t >= 1){
          r.resultA = r.a.list[irnd(0, r.a.list.length-1)];
          r.resultB = r.b.list[irnd(0, r.b.list.length-1)];
          finishRoulette();
        }
      }
      return;
    }

    if (game.laserActive){
      game.laserTimer -= dt;
      if (game.laserTimer <= 0){
        game.laserActive = false;
        game.laserTimer = 0;
      }
    }

    const scrollV = 80 + (game.level-1)*12;
    const scrollDy = scrollV * dt;
    game.stageProgress += scrollDy;
    for (const bl of game.blocks) bl.y += scrollDy;
    for (const cp of game.capsules) cp.y += scrollDy*0.3;
    for (const ms of game.missiles) ms.y += scrollDy*0.2;

    tick._rowT = (tick._rowT || 0) + dt;
    if (tick._rowT >= 0.65){
      tick._rowT = 0;
      spawnBlockRow();
    }

    spawnCapsuleRare();
    spawnMissileMaybe();

    const p = paddle();

    // Capsules
    for (const cp of game.capsules) cp.y += cp.vy * dt;

    for (let i=game.capsules.length-1; i>=0; i--){
      const cp = game.capsules[i];
      const coreX0 = p.x - p.coreW/2, coreY0 = p.y - p.coreH/2;
      if (aabbHitCircle(coreX0, coreY0, p.coreW, p.coreH, cp.x, cp.y, cp.r)){
        game.capsules.splice(i,1);
        startRoulette();
        if (navigator.vibrate) navigator.vibrate(10);
      } else if (cp.y > H + 40){
        game.capsules.splice(i,1);
      }
    }

    // Missiles
    for (let i=game.missiles.length-1; i>=0; i--){
      const m = game.missiles[i];
      m.y += m.vy * dt;
      const coreX0 = p.x - p.coreW/2, coreY0 = p.y - p.coreH/2;
      if (aabbHitCircle(coreX0, coreY0, p.coreW, p.coreH, m.x, m.y, m.r)){
        game.missiles.splice(i,1);
        burst(m.x, m.y, 22);
        loseLife();
        continue;
      }
      if (m.y > H + 40) game.missiles.splice(i,1);
    }

    // Balls
    const bounds = { l:12, r:W-12, t:12 };
    for (let bi=game.balls.length-1; bi>=0; bi--){
      const b = game.balls[bi];
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      if (b.x - b.r < bounds.l){ b.x = bounds.l + b.r; b.vx = Math.abs(b.vx); }
      if (b.x + b.r > bounds.r){ b.x = bounds.r - b.r; b.vx = -Math.abs(b.vx); }
      if (b.y - b.r < bounds.t){ b.y = bounds.t + b.r; b.vy = Math.abs(b.vy); }

      const coreX0 = p.x - p.coreW/2;
      const coreY0 = p.y - p.coreH/2;
      if (b.vy > 0 && aabbHitCircle(coreX0, coreY0, p.coreW, p.coreH, b.x, b.y, b.r)){
        b.y = coreY0 - b.r - 0.5;
        const nx = (b.x - p.x) / (p.coreW/2);
        const ang = (-0.9) + (1.8)*((nx+1)/2);
        const sp = clamp(Math.hypot(b.vx,b.vy)*1.02, 520, 920);
        b.vx = Math.sin(ang)*sp;
        b.vy = -Math.cos(ang)*sp;
        if (navigator.vibrate) navigator.vibrate(6);
        if (ac) beep(520,0.03,"square",0.35, 660);
      }

      if (b.y - b.r > H + 20){
        game.balls.splice(bi,1);
        if (game.balls.length === 0) loseLife();
      }
    }

    // Blocks
    for (let i=game.blocks.length-1; i>=0; i--){
      const bl = game.blocks[i];
      if (bl.y > H + 40){ game.blocks.splice(i,1); continue; }

      const coreX0 = p.x - p.coreW/2, coreY0 = p.y - p.coreH/2;
      if (aabbHitCircle(coreX0, coreY0, p.coreW, p.coreH, bl.x+bl.w/2, bl.y+bl.h/2, Math.max(bl.w,bl.h)/2)){
        game.blocks.splice(i,1);
        burst(bl.x+bl.w/2, bl.y+bl.h/2, 26);
        loseLife();
        continue;
      }

      for (const b of game.balls){
        if (!aabbHitCircle(bl.x, bl.y, bl.w, bl.h, b.x, b.y, b.r)) continue;

        if (bl.unbreak){
          if (ac) sfxClank();
          b.vy = -b.vy;
          continue;
        }
        bl.hp -= 1;
        if (ac) sfxHit();
        if (navigator.vibrate) navigator.vibrate(6);

        const cx = bl.x + bl.w/2, cy = bl.y + bl.h/2;
        const dx = (b.x - cx) / (bl.w/2);
        const dy = (b.y - cy) / (bl.h/2);
        if (Math.abs(dx) > Math.abs(dy)) b.vx = -b.vx;
        else b.vy = -b.vy;

        burst(b.x, b.y, 8);

        if (bl.hp <= 0){
          burst(bl.x+bl.w/2, bl.y+bl.h/2, 18);
          game.blocks.splice(i,1);
        }
        break;
      }
    }

    // Laser hits
    if (game.laserActive && game.blocks.length){
      tick._lzT = (tick._lzT || 0) + dt;
      if (tick._lzT > 0.12){ tick._lzT = 0; if (ac) sfxLaser(); }

      const beams = game.laserStage;
      const spread = (beams<=1) ? [0] : Array.from({length:beams}, (_,k)=>(-0.55) + (1.10)*(k/(beams-1)));
      const origin = { x:p.x, y:p.y-14 };
      const maxLen = 900;

      for (let i=game.blocks.length-1; i>=0; i--){
        const bl = game.blocks[i];
        if (bl.unbreak) continue;
        let hit = false;
        for (const ang of spread){
          const vx = Math.sin(ang), vy = -Math.cos(ang);
          const steps = 18;
          for (let s=1;s<=steps;s++){
            const t2 = (s/steps)*maxLen;
            const x = origin.x + vx*t2;
            const y = origin.y + vy*t2;
            if (x >= bl.x && x <= bl.x+bl.w && y >= bl.y && y <= bl.y+bl.h){ hit = true; break; }
          }
          if (hit) break;
        }
        if (hit){
          burst(bl.x+bl.w/2, bl.y+bl.h/2, 10);
          game.blocks.splice(i,1);
        }
      }
    }

    // Particles
    for (let i=game.particles.length-1; i>=0; i--){
      const pt = game.particles[i];
      pt.t += dt;
      pt.x += pt.vx * dt;
      pt.y += pt.vy * dt;
      pt.vy += 900 * dt;
      if (pt.t > pt.life) game.particles.splice(i,1);
    }

    if (game.stageProgress >= game.stageLength) nextStage();
    updateHud();
  }

  function hueShift(rgb, deg){
    const a = deg * Math.PI/180;
    const cosA = Math.cos(a), sinA = Math.sin(a);
    const r=rgb[0], g=rgb[1], b=rgb[2];
    const Y = 0.299*r + 0.587*g + 0.114*b;
    const I = 0.596*r - 0.274*g - 0.322*b;
    const Q = 0.211*r - 0.523*g + 0.312*b;
    const I2 = I*cosA - Q*sinA;
    const Q2 = I*sinA + Q*cosA;
    const rr = clamp(Y + 0.956*I2 + 0.621*Q2, 0, 255);
    const gg = clamp(Y - 0.272*I2 - 0.647*Q2, 0, 255);
    const bb = clamp(Y - 1.106*I2 + 1.703*Q2, 0, 255);
    return [rr|0,gg|0,bb|0];
  }

  function pixelRect(x,y,w,h){
    ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
  }

  function drawBigText(x,y,txt,size){
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "900 " + size + "px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillText(txt, x+2, y+2);
    ctx.fillStyle = "rgb(255,255,255)";
    ctx.fillText(txt, x, y);
    ctx.restore();
  }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = "#02030e";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const sx = canvas.width / W;
    const sy = canvas.height / H;
    ctx.setTransform(sx,0,0,sy,0,0);
    ctx.imageSmoothingEnabled = false;

    // starfield
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    for (let i=0;i<60;i++){
      const x = ((i*97)%W);
      const y = ((i*193 + game.time*40)%H);
      ctx.fillRect(x, y, 2, 2);
    }

    // blocks
    const pal = [
      [255,0,0],[0,255,0],[0,0,255],[255,255,0],[255,0,255],[0,255,255],[255,127,0]
    ].map(c=>hueShift(c, game.hue));

    for (const bl of game.blocks){
      let col = pal[(Math.floor(bl.x/10)+Math.floor(bl.y/10))%pal.length];
      if (bl.unbreak) col = [180,180,190];
      ctx.fillStyle = `rgb(${col[0]},${col[1]},${col[2]})`;
      pixelRect(bl.x, bl.y, bl.w, bl.h);

      ctx.fillStyle = "rgba(255,255,255,0.55)";
      pixelRect(bl.x, bl.y, bl.w, 3);

      ctx.strokeStyle = "rgba(0,0,0,0.65)";
      ctx.lineWidth = 2;
      ctx.strokeRect(bl.x+1, bl.y+1, bl.w-2, bl.h-2);

      if (bl.unbreak){
        ctx.strokeStyle = "rgba(0,0,0,0.75)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(bl.x+4, bl.y+4); ctx.lineTo(bl.x+bl.w-4, bl.y+bl.h-4);
        ctx.moveTo(bl.x+bl.w-4, bl.y+4); ctx.lineTo(bl.x+4, bl.y+bl.h-4);
        ctx.stroke();
      }
    }

    // capsules
    for (const cp of game.capsules){
      ctx.fillStyle = "rgb(0,255,255)";
      pixelRect(cp.x-12, cp.y-14, 24, 14);
      ctx.fillStyle = "rgb(255,0,255)";
      pixelRect(cp.x-12, cp.y, 24, 14);
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      pixelRect(cp.x-10, cp.y-12, 8, 4);
      ctx.strokeStyle = "rgba(0,0,0,0.8)";
      ctx.lineWidth = 2;
      ctx.strokeRect(cp.x-12, cp.y-14, 24, 28);
    }

    // missiles
    for (const m of game.missiles){
      ctx.fillStyle = "rgb(255,255,255)";
      pixelRect(m.x-3, m.y-8, 6, 16);
      ctx.fillStyle = "rgb(255,0,0)";
      pixelRect(m.x-5, m.y+6, 10, 6);
      ctx.strokeStyle = "rgba(0,0,0,0.8)";
      ctx.lineWidth = 2;
      ctx.strokeRect(m.x-5, m.y-8, 10, 22);
    }

    // paddle
    const p = paddle();
    const beamH = 10;
    const y = p.y - beamH/2;
    const lx0 = clamp(p.x - p.beamLen, 10, W-10);
    const lx1 = clamp(p.x + p.beamLen, 10, W-10);

    ctx.fillStyle = "rgb(255,0,255)";
    pixelRect(lx0, y, (p.x - p.coreW/2) - lx0, beamH);
    ctx.fillStyle = "rgb(0,255,255)";
    pixelRect((p.x + p.coreW/2), y, lx1 - (p.x + p.coreW/2), beamH);

    ctx.fillStyle = "rgb(240,240,240)";
    pixelRect(p.x - p.coreW/2, p.y - p.coreH/2, p.coreW, p.coreH);
    ctx.fillStyle = "rgb(120,120,130)";
    pixelRect(p.x - p.coreW/2, p.y + p.coreH/6, p.coreW, p.coreH/3);

    ctx.fillStyle = "rgb(0,255,0)";
    pixelRect(p.x - p.coreW/2 + 5, p.y - p.coreH/2 + 5, 4, 4);
    ctx.fillStyle = "rgb(255,0,0)";
    pixelRect(p.x + p.coreW/2 - 9, p.y - p.coreH/2 + 5, 4, 4);

    // active lasers
    if (game.laserActive){
      const beams = game.laserStage;
      const spread = (beams<=1) ? [0] : Array.from({length:beams}, (_,k)=>(-0.55) + (1.10)*(k/(beams-1)));
      const origin = { x:p.x, y:p.y-18 };
      const L = 900;
      ctx.globalAlpha = 0.80;
      for (const ang of spread){
        const vx = Math.sin(ang), vy = -Math.cos(ang);
        const x2 = origin.x + vx*L;
        const y2 = origin.y + vy*L;

        ctx.strokeStyle = "rgba(255,255,0,0.85)";
        ctx.lineWidth = 12;
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        ctx.strokeStyle = "rgba(255,255,255,0.85)";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // balls
    for (const b of game.balls){
      ctx.fillStyle = "rgb(255,0,0)";
      pixelRect(b.x-b.r, b.y-b.r, b.r*2, b.r*2);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      pixelRect(b.x-b.r+2, b.y-b.r+2, 4, 4);
    }

    // particles
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    for (const pt of game.particles){
      const a = 1 - (pt.t/pt.life);
      ctx.globalAlpha = a;
      pixelRect(pt.x, pt.y, pt.s, pt.s);
    }
    ctx.globalAlpha = 1;

    // roulette visuals
    if (game.paused && game.roulette){
      const r = game.roulette;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,W,H);

      const cx = W/2, cy = H/2 - 30;
      const w = 360, h = 160;
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      pixelRect(cx-w/2-10, cy-h/2-10, w+20, h+20);

      for (let i=0;i<10;i++){
        ctx.fillStyle = (i%2===0) ? "rgba(0,255,255,0.18)" : "rgba(255,0,255,0.18)";
        pixelRect(cx-w/2, cy-h/2 + i*(h/10), w, h/10);
      }
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      pixelRect(cx-w/2, cy-h/2, w, h);

      const aIdx = Math.floor(r.a.idx) % r.a.list.length;
      const bIdx = Math.floor(r.b.idx) % r.b.list.length;
      const A = r.a.list[aIdx];
      const B = r.b.list[bIdx];

      drawBigText(cx - 95, cy, A, 34);
      drawBigText(cx + 95, cy, String(B), 34);

      ctx.fillStyle = "rgba(255,255,255,0.18)";
      pixelRect(cx-2, cy-h/2+10, 4, h-20);

      for (let i=0;i<40;i++){
        ctx.fillStyle = (i%3===0) ? "rgba(255,255,0,0.85)" : "rgba(255,255,255,0.65)";
        const x = cx + Math.sin(i*1.7 + game.time*6)* (w*0.55) + rnd(-12,12);
        const y2 = cy + Math.cos(i*1.9 + game.time*7)* (h*0.55) + rnd(-12,12);
        pixelRect(x, y2, 3, 3);
      }

      drawBigText(cx, cy + 118, "ROULETTE!", 18);
    }

    if (game.running && game.waitingServe && !game.paused){
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      pixelRect(W/2-210, H/2-40, 420, 80);
      drawBigText(W/2, H/2, "SPACE / ENTER", 18);
    }
  }

  // Loop
  let last = performance.now();
  function frame(t){
    const dt = Math.max(0, Math.min(0.033, (t-last)/1000));
    last = t;
    tick(dt);
    draw();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // PWA
  if ("serviceWorker" in navigator){
    window.addEventListener("load", ()=>{
      navigator.serviceWorker.register("./sw.js").catch(()=>{});
    });
  }

  // initial state
  showOverlay();
  updateHud();

})();
</script>
</body>
</html>
